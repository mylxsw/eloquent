// !!! DO NOT EDIT THIS FILE
package migrate

import (
	"context"
	"database/sql"
	"github.com/mylxsw/eloquent/query"
	"gopkg.in/guregu/null.v3"
)

func init() {

}

// Migrations is a Migrations object
type Migrations struct {
	original *migrationsOriginal

	Id        int64
	Version   string
	Migration string
	Table     string
	Batch     int64
}

// migrationsOriginal is an object which stores original Migrations from database
type migrationsOriginal struct {
	Id        int64
	Version   string
	Migration string
	Table     string
	Batch     int64
}

// Staled identify whether the object has been modified
func (migrations *Migrations) Staled() bool {
	if migrations.original == nil {
		migrations.original = &migrationsOriginal{}
	}

	if migrations.Id != migrations.original.Id {
		return true
	}

	if migrations.Version != migrations.original.Version {
		return true
	}
	if migrations.Migration != migrations.original.Migration {
		return true
	}
	if migrations.Table != migrations.original.Table {
		return true
	}
	if migrations.Batch != migrations.original.Batch {
		return true
	}

	return false
}

// StaledKV return all fields has been modified
func (migrations *Migrations) StaledKV() query.KV {
	kv := make(query.KV, 0)

	if migrations.original == nil {
		migrations.original = &migrationsOriginal{}
	}

	if migrations.Id != migrations.original.Id {
		kv["id"] = migrations.Id
	}

	if migrations.Version != migrations.original.Version {
		kv["version"] = migrations.Version
	}
	if migrations.Migration != migrations.original.Migration {
		kv["migration"] = migrations.Migration
	}
	if migrations.Table != migrations.original.Table {
		kv["table"] = migrations.Table
	}
	if migrations.Batch != migrations.original.Batch {
		kv["batch"] = migrations.Batch
	}

	return kv
}

// MigrationsDelegate is an delegate which add some model powers to object
type MigrationsDelegate struct {
	delegate   *MigrationsModel
	migrations *Migrations
}

// Delegate create a Migrations for migrations
func (migrations *Migrations) Delegate(m *MigrationsModel) *MigrationsDelegate {
	return &MigrationsDelegate{
		delegate:   m,
		migrations: migrations,
	}
}

// Save create a new model or update it
func (d *MigrationsDelegate) Save() error {
	id, _, err := d.delegate.SaveOrUpdate(*d.migrations)
	if err != nil {
		return err
	}

	d.migrations.Id = id
	return nil
}

// Delete remove a migrations
func (d *MigrationsDelegate) Delete() error {
	_, err := d.delegate.DeleteById(d.migrations.Id)
	if err != nil {
		return err
	}

	return nil
}

type migrationsWrap struct {
	Id        null.Int
	Version   null.String
	Migration null.String
	Table     null.String
	Batch     null.Int
}

func (w migrationsWrap) ToMigrations() Migrations {
	return Migrations{
		original: &migrationsOriginal{
			Id:        w.Id.Int64,
			Version:   w.Version.String,
			Migration: w.Migration.String,
			Table:     w.Table.String,
			Batch:     w.Batch.Int64,
		},
		Id:        w.Id.Int64,
		Version:   w.Version.String,
		Migration: w.Migration.String,
		Table:     w.Table.String,
		Batch:     w.Batch.Int64,
	}
}

// MigrationsModel is a model which encapsulates the operations of the object
type MigrationsModel struct {
	db        query.Database
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes  []string
}

type migrationsScope struct {
	name  string
	apply func(builder query.Condition)
}

var migrationsGlobalScopes = make([]migrationsScope, 0)
var migrationsLocalScopes = make([]migrationsScope, 0)

var migrationsTableName = "migrations"

func SetMigrationsTable(tableName string) {
	migrationsTableName = tableName
}

// NewMigrationsModel create a MigrationsModel
func NewMigrationsModel(db query.Database) *MigrationsModel {
	return &MigrationsModel{
		db:                  db,
		tableName:           migrationsTableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes:  make([]string, 0),
	}
}

// AddMigrationsGlobalScope assign a global scope to a model
func AddMigrationsGlobalScope(name string, apply func(builder query.Condition)) {
	migrationsGlobalScopes = append(migrationsGlobalScopes, migrationsScope{name: name, apply: apply})
}

// AddMigrationsLocalScope assign a local scope to a model
func AddMigrationsLocalScope(name string, apply func(builder query.Condition)) {
	migrationsLocalScopes = append(migrationsLocalScopes, migrationsScope{name: name, apply: apply})
}

func (m *MigrationsModel) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range migrationsGlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range migrationsLocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *MigrationsModel) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *MigrationsModel) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}

	return true
}

func (m *MigrationsModel) clone() *MigrationsModel {
	return &MigrationsModel{
		db:                  m.db,
		tableName:           m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes:  append([]string{}, m.includeLocalScopes...),
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *MigrationsModel) WithoutGlobalScopes(names ...string) *MigrationsModel {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *MigrationsModel) WithLocalScopes(names ...string) *MigrationsModel {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Find retrieve a model by its primary key
func (m *MigrationsModel) Find(id int64) (Migrations, error) {
	return m.First(query.Builder().Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *MigrationsModel) Exists(builder query.SQLBuilder) (bool, error) {
	count, err := m.Count(builder)
	return count > 0, err
}

// Count return model count for a given query
func (m *MigrationsModel) Count(builder query.SQLBuilder) (int64, error) {
	sqlStr, params := builder.Table(m.tableName).ResolveCount()

	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *MigrationsModel) Paginate(builder query.SQLBuilder, page int64, perPage int64) ([]Migrations, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta{
		PerPage: perPage,
		Page:    page,
	}

	count, err := m.Count(builder)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count%perPage != 0 {
		meta.LastPage += 1
	}

	res, err := m.Get(builder.Limit(perPage).Offset((page - 1) * perPage))
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *MigrationsModel) Get(builder query.SQLBuilder) ([]Migrations, error) {
	builder = builder.Table(m.tableName).Select("id", "version", "migration", "table", "batch")
	sqlStr, params := builder.AppendCondition(m.applyScope()).ResolveQuery()

	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return nil, err
	}

	migrationss := make([]Migrations, 0)
	for rows.Next() {
		var migrationsVar migrationsWrap
		if err := rows.Scan(&migrationsVar.Id, &migrationsVar.Version, &migrationsVar.Migration, &migrationsVar.Table, &migrationsVar.Batch); err != nil {
			return nil, err
		}

		migrationss = append(migrationss, migrationsVar.ToMigrations())
	}

	return migrationss, nil
}

// First return first result for given query
func (m *MigrationsModel) First(builder query.SQLBuilder) (Migrations, error) {
	res, err := m.Get(builder.Limit(1))
	if err != nil {
		return Migrations{}, err
	}

	if len(res) == 0 {
		return Migrations{}, sql.ErrNoRows
	}

	return res[0], nil
}

// Create save a new migrations to database
func (m *MigrationsModel) Create(kv query.KV) (int64, error) {

	sqlStr, params := query.Builder().Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all migrationss to database
func (m *MigrationsModel) SaveAll(migrationss []Migrations) ([]int64, error) {
	ids := make([]int64, 0)
	for _, migrations := range migrationss {
		id, err := m.Save(migrations)
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a migrations to database
func (m *MigrationsModel) Save(migrations Migrations) (int64, error) {
	return m.Create(query.KV{
		"version":   migrations.Version,
		"migration": migrations.Migration,
		"table":     migrations.Table,
		"batch":     migrations.Batch,
	})
}

// SaveOrUpdate save a new migrations or update it when it has a id > 0
func (m *MigrationsModel) SaveOrUpdate(migrations Migrations) (id int64, updated bool, err error) {
	if migrations.Id > 0 {
		_, _err := m.UpdateById(migrations.Id, migrations)
		return migrations.Id, true, _err
	}

	_id, _err := m.Save(migrations)
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *MigrationsModel) UpdateFields(builder query.SQLBuilder, kv query.KV) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	builder = builder.AppendCondition(m.applyScope())
	sqlStr, params := builder.Table(m.tableName).ResolveUpdate(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *MigrationsModel) Update(builder query.SQLBuilder, migrations Migrations) (int64, error) {
	return m.UpdateFields(builder, migrations.StaledKV())
}

// UpdateById update a model by id
func (m *MigrationsModel) UpdateById(id int64, migrations Migrations) (int64, error) {
	return m.Update(query.Builder().Where("id", "=", id), migrations)
}

// Delete remove a model
func (m *MigrationsModel) Delete(builder query.SQLBuilder) (int64, error) {

	sqlStr, params := builder.AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()

}

// DeleteById remove a model by id
func (m *MigrationsModel) DeleteById(id int64) (int64, error) {
	return m.Delete(query.Builder().Where("id", "=", id))
}
