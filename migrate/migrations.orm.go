package migrate

// !!! DO NOT EDIT THIS FILE

import (
	"context"
	"github.com/mylxsw/eloquent/query"
	"gopkg.in/guregu/null.v3"
)

func init() {

}

// Migrations is a Migrations object
type Migrations struct {
	original        *migrationsOriginal
	migrationsModel *MigrationsModel

	Version   string
	Migration string
	Table     string
	Batch     int64
	Id        int64
}

// SetModel set model for Migrations
func (migrationsSelf *Migrations) SetModel(migrationsModel *MigrationsModel) {
	migrationsSelf.migrationsModel = migrationsModel
}

// migrationsOriginal is an object which stores original Migrations from database
type migrationsOriginal struct {
	Version   string
	Migration string
	Table     string
	Batch     int64
	Id        int64
}

// Staled identify whether the object has been modified
func (migrationsSelf *Migrations) Staled() bool {
	if migrationsSelf.original == nil {
		migrationsSelf.original = &migrationsOriginal{}
	}

	if migrationsSelf.Version != migrationsSelf.original.Version {
		return true
	}
	if migrationsSelf.Migration != migrationsSelf.original.Migration {
		return true
	}
	if migrationsSelf.Table != migrationsSelf.original.Table {
		return true
	}
	if migrationsSelf.Batch != migrationsSelf.original.Batch {
		return true
	}
	if migrationsSelf.Id != migrationsSelf.original.Id {
		return true
	}

	return false
}

// StaledKV return all fields has been modified
func (migrationsSelf *Migrations) StaledKV() query.KV {
	kv := make(query.KV, 0)

	if migrationsSelf.original == nil {
		migrationsSelf.original = &migrationsOriginal{}
	}

	if migrationsSelf.Version != migrationsSelf.original.Version {
		kv["version"] = migrationsSelf.Version
	}
	if migrationsSelf.Migration != migrationsSelf.original.Migration {
		kv["migration"] = migrationsSelf.Migration
	}
	if migrationsSelf.Table != migrationsSelf.original.Table {
		kv["table"] = migrationsSelf.Table
	}
	if migrationsSelf.Batch != migrationsSelf.original.Batch {
		kv["batch"] = migrationsSelf.Batch
	}
	if migrationsSelf.Id != migrationsSelf.original.Id {
		kv["id"] = migrationsSelf.Id
	}

	return kv
}

// Save create a new model or update it
func (migrationsSelf *Migrations) Save() error {
	if migrationsSelf.migrationsModel == nil {
		return query.ErrModelNotSet
	}

	id, _, err := migrationsSelf.migrationsModel.SaveOrUpdate(*migrationsSelf)
	if err != nil {
		return err
	}

	migrationsSelf.Id = id
	return nil
}

// Delete remove a migrations
func (migrationsSelf *Migrations) Delete() error {
	if migrationsSelf.migrationsModel == nil {
		return query.ErrModelNotSet
	}

	_, err := migrationsSelf.migrationsModel.DeleteById(migrationsSelf.Id)
	if err != nil {
		return err
	}

	return nil
}

type migrationsScope struct {
	name  string
	apply func(builder query.Condition)
}

var migrationsGlobalScopes = make([]migrationsScope, 0)
var migrationsLocalScopes = make([]migrationsScope, 0)

// AddMigrationsGlobalScope assign a global scope to a model
func AddMigrationsGlobalScope(name string, apply func(builder query.Condition)) {
	migrationsGlobalScopes = append(migrationsGlobalScopes, migrationsScope{name: name, apply: apply})
}

// AddMigrationsLocalScope assign a local scope to a model
func AddMigrationsLocalScope(name string, apply func(builder query.Condition)) {
	migrationsLocalScopes = append(migrationsLocalScopes, migrationsScope{name: name, apply: apply})
}

func (m *MigrationsModel) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range migrationsGlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range migrationsLocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *MigrationsModel) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *MigrationsModel) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}

	return true
}

type migrationsWrap struct {
	Version   null.String
	Migration null.String
	Table     null.String
	Batch     null.Int
	Id        null.Int
}

func (w migrationsWrap) ToMigrations() Migrations {
	return Migrations{
		original: &migrationsOriginal{
			Version:   w.Version.String,
			Migration: w.Migration.String,
			Table:     w.Table.String,
			Batch:     w.Batch.Int64,
			Id:        w.Id.Int64,
		},

		Version:   w.Version.String,
		Migration: w.Migration.String,
		Table:     w.Table.String,
		Batch:     w.Batch.Int64,
		Id:        w.Id.Int64,
	}
}

// MigrationsModel is a model which encapsulates the operations of the object
type MigrationsModel struct {
	db        *query.DatabaseWrap
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes  []string

	query query.SQLBuilder
}

var migrationsTableName = "migrations"

func SetMigrationsTable(tableName string) {
	migrationsTableName = tableName
}

// NewMigrationsModel create a MigrationsModel
func NewMigrationsModel(db query.Database) *MigrationsModel {
	return &MigrationsModel{
		db:                  query.NewDatabaseWrap(db),
		tableName:           migrationsTableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes:  make([]string, 0),
		query:               query.Builder(),
	}
}

// GetDB return database instance
func (m *MigrationsModel) GetDB() query.Database {
	return m.db.GetDB()
}

func (m *MigrationsModel) clone() *MigrationsModel {
	return &MigrationsModel{
		db:                  m.db,
		tableName:           m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes:  append([]string{}, m.includeLocalScopes...),
		query:               m.query,
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *MigrationsModel) WithoutGlobalScopes(names ...string) *MigrationsModel {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *MigrationsModel) WithLocalScopes(names ...string) *MigrationsModel {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Query add query builder to model
func (m *MigrationsModel) Query(builder query.SQLBuilder) *MigrationsModel {
	mm := m.clone()
	mm.query = mm.query.Merge(builder)

	return mm
}

// Find retrieve a model by its primary key
func (m *MigrationsModel) Find(id int64) (Migrations, error) {
	return m.First(m.query.Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *MigrationsModel) Exists(builders ...query.SQLBuilder) (bool, error) {
	count, err := m.Count(builders...)
	return count > 0, err
}

// Count return model count for a given query
func (m *MigrationsModel) Count(builders ...query.SQLBuilder) (int64, error) {
	sqlStr, params := m.query.
		Merge(builders...).
		Table(m.tableName).
		AppendCondition(m.applyScope()).
		ResolveCount()

	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	defer rows.Close()

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *MigrationsModel) Paginate(page int64, perPage int64, builders ...query.SQLBuilder) ([]Migrations, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta{
		PerPage: perPage,
		Page:    page,
	}

	count, err := m.Count(builders...)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count%perPage != 0 {
		meta.LastPage += 1
	}

	res, err := m.Get(append([]query.SQLBuilder{query.Builder().Limit(perPage).Offset((page - 1) * perPage)}, builders...)...)
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *MigrationsModel) Get(builders ...query.SQLBuilder) ([]Migrations, error) {
	sqlStr, params := m.query.Merge(builders...).
		Table(m.tableName).
		Select(
			"version",
			"migration",
			"table",
			"batch",
			"id",
		).AppendCondition(m.applyScope()).
		ResolveQuery()

	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	migrationss := make([]Migrations, 0)
	for rows.Next() {
		var migrationsVar migrationsWrap
		if err := rows.Scan(
			&migrationsVar.Version,
			&migrationsVar.Migration,
			&migrationsVar.Table,
			&migrationsVar.Batch,
			&migrationsVar.Id); err != nil {
			return nil, err
		}

		migrationsReal := migrationsVar.ToMigrations()
		migrationsReal.SetModel(m)
		migrationss = append(migrationss, migrationsReal)
	}

	return migrationss, nil
}

// First return first result for given query
func (m *MigrationsModel) First(builders ...query.SQLBuilder) (Migrations, error) {
	res, err := m.Get(append(builders, query.Builder().Limit(1))...)
	if err != nil {
		return Migrations{}, err
	}

	if len(res) == 0 {
		return Migrations{}, query.ErrNoResult
	}

	return res[0], nil
}

// Create save a new migrations to database
func (m *MigrationsModel) Create(kv query.KV) (int64, error) {

	sqlStr, params := m.query.Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all migrationss to database
func (m *MigrationsModel) SaveAll(migrationss []Migrations) ([]int64, error) {
	ids := make([]int64, 0)
	for _, migrations := range migrationss {
		id, err := m.Save(migrations)
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a migrations to database
func (m *MigrationsModel) Save(migrations Migrations) (int64, error) {
	return m.Create(query.KV{
		"version":   migrations.Version,
		"migration": migrations.Migration,
		"table":     migrations.Table,
		"batch":     migrations.Batch,
	})
}

// SaveOrUpdate save a new migrations or update it when it has a id > 0
func (m *MigrationsModel) SaveOrUpdate(migrations Migrations) (id int64, updated bool, err error) {
	if migrations.Id > 0 {
		_, _err := m.UpdateById(migrations.Id, migrations)
		return migrations.Id, true, _err
	}

	_id, _err := m.Save(migrations)
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *MigrationsModel) UpdateFields(kv query.KV, builders ...query.SQLBuilder) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).
		Table(m.tableName).
		ResolveUpdate(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *MigrationsModel) Update(migrations Migrations) (int64, error) {
	return m.UpdateFields(migrations.StaledKV())
}

// UpdateById update a model by id
func (m *MigrationsModel) UpdateById(id int64, migrations Migrations) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Update(migrations)
}

// Delete remove a model
func (m *MigrationsModel) Delete(builders ...query.SQLBuilder) (int64, error) {

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()

}

// DeleteById remove a model by id
func (m *MigrationsModel) DeleteById(id int64) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Delete()
}
