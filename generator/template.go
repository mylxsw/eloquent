package generator

import (
	"fmt"
)

var temp = `
package {{ .PackageName }} 

// !!! DO NOT EDIT THIS FILE

import (
	{{ range $i, $imp := packages }}
	"{{ $imp }}"{{ end }}
)

func init() {
{{ range $i, $m := .Models }}{{ if $m.Definition.SoftDelete }}
	// Add{{camel $m.Name }}GlobalScope assign a global scope to a model for soft delete
	Add{{ camel $m.Name }}GlobalScope("soft_delete", func(builder query.Condition) {
		builder.WhereNull("deleted_at")
	})
{{ end }}{{ end }}
}

{{ range $i, $m := .Models }}
%s
%s
%s
%s
%s
%s
{{ end }}
`

var tempModel = `
// {{ camel $m.Name }}Model is a model which encapsulates the operations of the object
type {{ camel $m.Name }}Model struct {
	db *query.DatabaseWrap
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes []string
	
	query query.SQLBuilder
}

var {{ lowercase $m.Name }}TableName = "{{ table $i }}"

func Set{{ camel $m.Name }}Table (tableName string) {
	{{ lowercase $m.Name }}TableName = tableName
}

// New{{ camel $m.Name }}Model create a {{ camel $m.Name }}Model
func New{{ camel $m.Name }}Model (db query.Database) *{{ camel $m.Name }}Model {
	return &{{ camel $m.Name }}Model {
		db: query.NewDatabaseWrap(db), 
		tableName: {{ lowercase $m.Name }}TableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes: make([]string, 0),
		query: query.Builder(),
	}
}

// GetDB return database instance
func (m *{{ camel $m.Name }}Model) GetDB() query.Database {
	return m.db.GetDB()
}

{{ if $m.Definition.SoftDelete }}
// WithTrashed force soft deleted models to appear in a result set
func (m *{{ camel $m.Name }}Model) WithTrashed() *{{ camel $m.Name }}Model {
	return m.WithoutGlobalScopes("soft_delete")
}
{{ end }}

func (m *{{ camel $m.Name }}Model) clone() *{{ camel $m.Name }}Model {
	return &{{ camel $m.Name }}Model{
		db: m.db, 
		tableName: m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes: append([]string{}, m.includeLocalScopes...),
		query: m.query,
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *{{ camel $m.Name }}Model) WithoutGlobalScopes(names ...string) *{{ camel $m.Name }}Model {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *{{ camel $m.Name }}Model) WithLocalScopes(names ...string) *{{ camel $m.Name }}Model {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Query add query builder to model
func (m *{{ camel $m.Name }}Model) Query(builder query.SQLBuilder) *{{ camel $m.Name }}Model {
	mm := m.clone()
	mm.query = mm.query.Merge(builder)

	return mm
}

// Find retrieve a model by its primary key
func (m *{{ camel $m.Name }}Model) Find(id int64) ({{ camel $m.Name }}, error) {
	return m.First(m.query.Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *{{ camel $m.Name }}Model) Exists(builders ...query.SQLBuilder) (bool, error) {
	count, err := m.Count(builders...)
	return count > 0, err
}

// Count return model count for a given query
func (m *{{ camel $m.Name }}Model) Count(builders ...query.SQLBuilder) (int64, error) {
	sqlStr, params := m.query.
		Merge(builders...).
		Table(m.tableName).
		AppendCondition(m.applyScope()).
		ResolveCount()
	
	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	defer rows.Close()

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *{{ camel $m.Name }}Model) Paginate(page int64, perPage int64, builders ...query.SQLBuilder) ([]{{ camel $m.Name }}, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta {
		PerPage: perPage,
		Page: page,
	}

	count, err := m.Count(builders...)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count % perPage != 0 {
		meta.LastPage += 1
	}


	res, err := m.Get(append([]query.SQLBuilder{query.Builder().Limit(perPage).Offset((page - 1) * perPage)}, builders...)...)
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *{{ camel $m.Name }}Model) Get(builders ...query.SQLBuilder) ([]{{ camel $m.Name }}, error) {
	sqlStr, params := m.query.Merge(builders...).
		Table(m.tableName).
		Select({{ range $j, $f := fields $m.Definition }}
			"{{ snake $f.Name }}",{{ end }}
		).AppendCondition(m.applyScope()).
		ResolveQuery()
	
	rows, err := m.db.QueryContext(context.Background(), sqlStr, params...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	{{ lowercase $m.Name }}s := make([]{{ camel $m.Name }}, 0)
	for rows.Next() {
		var {{ lowercase $m.Name }}Var {{ lower_camel $m.Name }}Wrap
		if err := rows.Scan({{ range $j, $f := fields $m.Definition }} 
			&{{ lowercase $m.Name }}Var.{{ camel $f.Name }},{{ end }}); err != nil {
			return nil, err
		}

		{{ lowercase $m.Name }}Real := {{ lowercase $m.Name }}Var.To{{ camel $m.Name }}()
		{{ lowercase $m.Name }}Real.SetModel(m)
		{{ lowercase $m.Name }}s = append({{ lowercase $m.Name }}s, {{ lowercase $m.Name }}Real)
	}

	return {{ lowercase $m.Name }}s, nil
}

// First return first result for given query
func (m *{{ camel $m.Name }}Model) First(builders ...query.SQLBuilder) ({{ camel $m.Name }}, error) {
	res, err := m.Get(append(builders, query.Builder().Limit(1))...)
	if err != nil {
		return {{ camel $m.Name }}{}, err 
	}

	if len(res) == 0 {
		return {{ camel $m.Name }}{}, query.ErrNoResult
	}

	return res[0], nil
}

// Create save a new {{ $m.Name }} to database
func (m *{{ camel $m.Name }}Model) Create(kv query.KV) (int64, error) {
	{{ if not $m.Definition.WithoutCreateTime }}kv["created_at"] = time.Now(){{ end }}
	{{ if not $m.Definition.WithoutUpdateTime }}kv["updated_at"] = time.Now(){{ end }}

	sqlStr, params := m.query.Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()
}

// SaveAll save all {{ $m.Name }}s to database
func (m *{{ camel $m.Name }}Model) SaveAll({{ lowercase $m.Name }}s []{{ camel $m.Name }}) ([]int64, error) {
	ids := make([]int64, 0)
	for _, {{ lowercase $m.Name }} := range {{ lowercase $m.Name }}s {
		id, err := m.Save({{ lowercase $m.Name }})
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a {{ $m.Name }} to database
func (m *{{ camel $m.Name }}Model) Save({{ lowercase $m.Name }} {{ camel $m.Name }}) (int64, error) {
	return m.Create(query.KV{ {{ range $j, $f := assignable_fields $m.Definition }}
		"{{ snake $f.Name }}": {{ lowercase $m.Name }}.{{ camel $f.Name }},{{ end }}
	})	
}

// SaveOrUpdate save a new {{ $m.Name }} or update it when it has a id > 0
func (m *{{ camel $m.Name }}Model) SaveOrUpdate({{ lowercase $m.Name }} {{ camel $m.Name }}) (id int64, updated bool, err error) {
	if {{ lowercase $m.Name }}.Id > 0 {
		_, _err := m.UpdateById({{ lowercase $m.Name }}.Id, {{ lowercase $m.Name }})
		return {{ lowercase $m.Name }}.Id, true, _err
	}

	_id, _err := m.Save({{ lowercase $m.Name }})
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *{{ camel $m.Name }}Model) UpdateFields(kv query.KV, builders ...query.SQLBuilder) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	{{ if not $m.Definition.WithoutUpdateTime }}
	kv["updated_at"] = time.Now()
	{{ end }}

	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).
		Table(m.tableName).
		ResolveUpdate(kv)

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *{{ camel $m.Name }}Model) Update({{ lowercase $m.Name }} {{ camel $m.Name }}) (int64, error) {
	return m.UpdateFields({{ lowercase $m.Name }}.StaledKV())
}

// UpdateById update a model by id
func (m *{{ camel $m.Name }}Model) UpdateById(id int64, {{ lowercase $m.Name }} {{ camel $m.Name }}) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Update({{ lowercase $m.Name }})
}

{{ if $m.Definition.SoftDelete }}
// ForceDelete permanently remove a soft deleted model from the database
func (m *{{ camel $m.Name }}Model) ForceDelete(builders ...query.SQLBuilder) (int64, error) {
	m2 := m.WithTrashed()

	sqlStr, params := m2.query.Merge(builders...).AppendCondition(m2.applyScope()).Table(m2.tableName).ResolveDelete()

	res, err := m2.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// ForceDeleteById permanently remove a soft deleted model from the database by id
func (m *{{ camel $m.Name }}Model) ForceDeleteById(id int64) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).ForceDelete()
}

// Restore restore a soft deleted model into an active state
func (m *{{ camel $m.Name }}Model) Restore(builders ...query.SQLBuilder) (int64, error) {
	m2 := m.WithTrashed()
	return m2.UpdateFields(query.KV {
		"deleted_at": nil,
	}, builders...)
}

// RestoreById restore a soft deleted model into an active state by id
func (m *{{ camel $m.Name }}Model) RestoreById(id int64) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Restore()
}
{{ end }}

// Delete remove a model
func (m *{{ camel $m.Name }}Model) Delete(builders ...query.SQLBuilder) (int64, error) {
	{{ if $m.Definition.SoftDelete }}
	return m.UpdateFields(query.KV {
		"deleted_at": time.Now(),
	}, builders...)
	{{ else }}
	sqlStr, params := m.query.Merge(builders...).AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.ExecContext(context.Background(), sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
	{{ end }}
}

// DeleteById remove a model by id
func (m *{{ camel $m.Name }}Model) DeleteById(id int64) (int64, error) {
	return m.Query(query.Builder().Where("id", "=", id)).Delete()
}
`

var tempScope = `
type {{ lowercase $m.Name }}Scope struct {
	name  string
	apply func(builder query.Condition)
}

var {{ lowercase $m.Name }}GlobalScopes = make([]{{ lowercase $m.Name }}Scope, 0)
var {{ lowercase $m.Name }}LocalScopes = make([]{{ lowercase $m.Name }}Scope, 0)

// Add{{ camel $m.Name }}GlobalScope assign a global scope to a model
func Add{{ camel $m.Name }}GlobalScope(name string, apply func(builder query.Condition)) {
	{{ lowercase $m.Name }}GlobalScopes = append({{ lowercase $m.Name }}GlobalScopes, {{ lowercase $m.Name }}Scope{name: name, apply: apply})
}

// Add{{ camel $m.Name }}LocalScope assign a local scope to a model
func Add{{ camel $m.Name }}LocalScope(name string, apply func(builder query.Condition)) {
	{{ lowercase $m.Name }}LocalScopes = append({{ lowercase $m.Name }}LocalScopes, {{ lowercase $m.Name }}Scope{name: name, apply: apply})
}

func (m *{{ camel $m.Name }}Model) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range {{ lowercase $m.Name }}GlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range {{ lowercase $m.Name }}LocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *{{ camel $m.Name }}Model) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *{{ camel $m.Name }}Model) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}
	
	return true
}
`

var tempWrap = `
type {{ lower_camel $m.Name }}Wrap struct { {{ range $j, $f := fields $m.Definition }}	
	{{ camel $f.Name }} {{ wrap_type $f.Type }}{{ end }}
}

func (w {{ lower_camel $m.Name }}Wrap) To{{ camel $m.Name }} () {{ camel $m.Name }} {
	return {{ camel $m.Name }} {
		original: &{{ lowercase $m.Name }}Original { {{ range $j, $f := fields $m.Definition }}
			{{ camel $f.Name }}: {{ unwrap_type $f.Name $f.Type }},{{ end }}
		},
		{{ range $j, $f := fields $m.Definition }}
		{{ camel $f.Name }}: {{ unwrap_type $f.Name $f.Type }},{{ end }}
	}
}
`

var tempRelation = `
{{ range $j, $rel := $m.Relations }}
{{ if rel $rel | eq "belongsTo" }}
{{ $relName := rel_belongs_to_name $rel $m }}
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) {{ rel_method $rel }}() *{{ $relName }} {
	return &{{ $relName }} {
		source: {{ lowercase $m.Name }}Self,
		relModel: {{ rel_package_prefix $rel }}New{{ camel $rel.Model }}Model({{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model.GetDB()),
	}
}

type {{ $relName }} struct {
	source *{{ camel $m.Name }}
	relModel *{{ rel_package_prefix $rel }}{{ camel $rel.Model }}Model
}

func (rel *{{ $relName }}) Create(target {{ camel $rel.Model }}) (int64, error) {
	targetId, err := rel.relModel.Save(target)
	if err != nil {
		return 0, err
	}

	target.Id = targetId

	rel.source.{{ rel_foreign_key $rel | camel }} = target.{{ rel_owner_key $rel | camel }}
	if err := rel.source.Save(); err != nil {
		return targetId, err
	}

	return targetId, nil
}

func (rel *{{ $relName }}) Exists(builders ...query.SQLBuilder) (bool, error) {
	builder := query.Builder().Where("{{ rel_owner_key $rel | snake }}", rel.source.{{ rel_foreign_key $rel | camel }}).Merge(builders...)
	
	return rel.relModel.Exists(builder)
}

func (rel *{{ $relName }}) First(builders ...query.SQLBuilder) ({{ camel $rel.Model }}, error) {
	builder := query.Builder().Where("{{ rel_owner_key $rel | snake }}", rel.source.{{ rel_foreign_key $rel | camel }}).Limit(1).Merge(builders...)

	return rel.relModel.First(builder)
}

func (rel *{{ $relName }}) Associate(target {{ camel $rel.Model }}) error {
	rel.source.{{ rel_foreign_key $rel | camel }} = target.{{ rel_owner_key $rel | camel }}
	return rel.source.Save()
}

func (rel *{{ $relName }}) Dissociate() error {
	rel.source.{{ rel_foreign_key $rel | camel }} = 0
	return rel.source.Save()
}
{{ end }}

{{ if rel $rel | eq "hasMany" }}
{{ $relName := rel_has_many_name $rel $m }}
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) {{ rel_method $rel }}() *{{ $relName }} {
	return &{{ $relName }} {
		source: {{ lowercase $m.Name }}Self,
		relModel: {{ rel_package_prefix $rel }}New{{ camel $rel.Model }}Model({{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model.GetDB()),
	}
}

type {{ $relName }} struct {
	source *{{ camel $m.Name }}
	relModel *{{ rel_package_prefix $rel }}{{ camel $rel.Model }}Model
}

func (rel *{{ $relName }}) Get(builders ...query.SQLBuilder) ([]{{ camel $rel.Model }}, error) {
	builder := query.Builder().Where("{{ rel_foreign_key_rev $rel $m | snake }}", rel.source.{{ rel_local_key $rel | camel }}).Merge(builders...)

	return rel.relModel.Get(builder)
}

func (rel *{{ $relName }}) Count(builders ...query.SQLBuilder) (int64, error) {
	builder := query.Builder().Where("{{ rel_foreign_key_rev $rel $m | snake }}", rel.source.{{ rel_local_key $rel | camel }}).Merge(builders...)
	
	return rel.relModel.Count(builder)
}

func (rel *{{ $relName }}) Exists(builders ...query.SQLBuilder) (bool, error) {
	builder := query.Builder().Where("{{ rel_foreign_key_rev $rel $m | snake }}", rel.source.{{ rel_local_key $rel | camel }}).Merge(builders...)
	
	return rel.relModel.Exists(builder)
}

func (rel *{{ $relName }}) First(builders ...query.SQLBuilder) ({{ camel $rel.Model }}, error) {
	builder := query.Builder().Where("{{ rel_foreign_key_rev $rel $m | snake }}", rel.source.{{ rel_local_key $rel | camel }}).Limit(1).Merge(builders...)
	return rel.relModel.First(builder)
}

func (rel *{{ $relName }}) Create(target {{ camel $rel.Model }}) (int64, error) {
	target.RoleId = rel.source.Id
	return rel.relModel.Save(target)
}
{{ end }}

{{ end }}



`

var tempEntity = `
// {{ camel $m.Name }} is a {{ camel $m.Name }} object
type {{ camel $m.Name }} struct {
	original *{{ lowercase $m.Name }}Original
	{{ lowercase $m.Name }}Model *{{ camel $m.Name }}Model

	{{ range $j, $f := fields $m.Definition }}
	{{ camel $f.Name }} {{ $f.Type }} {{ tag $f }}{{ end }}
}

// SetModel set model for {{ camel $m.Name }}
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) SetModel({{ lowercase $m.Name }}Model *{{ camel $m.Name }}Model) {
	{{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model = {{ lowercase $m.Name }}Model
}

// {{ lowercase $m.Name }}Original is an object which stores original {{ camel $m.Name }} from database
type {{ lowercase $m.Name }}Original struct {
	{{ range $j, $f := fields $m.Definition }}
	{{ camel $f.Name }} {{ $f.Type }}{{ end }}
}

// Staled identify whether the object has been modified
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) Staled() bool {
	if {{ lowercase $m.Name }}Self.original == nil {
		{{ lowercase $m.Name }}Self.original = &{{ lowercase $m.Name }}Original {}
	}

	{{ range $j, $f := fields $m.Definition }}
	if {{ lowercase $m.Name }}Self.{{ camel $f.Name }} != {{ lowercase $m.Name }}Self.original.{{ camel $f.Name }} {
		return true
	}{{ end }}

	return false
}

// StaledKV return all fields has been modified
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) StaledKV() query.KV {
	kv := make(query.KV, 0)

	if {{ lowercase $m.Name }}Self.original == nil {
		{{ lowercase $m.Name }}Self.original = &{{ lowercase $m.Name }}Original {}
	}

	{{ range $j, $f := fields $m.Definition }}
	if {{ lowercase $m.Name }}Self.{{ camel $f.Name }} != {{ lowercase $m.Name }}Self.original.{{ camel $f.Name }} {
		kv["{{ snake $f.Name }}"] = {{ lowercase $m.Name }}Self.{{ camel $f.Name }}
	}{{ end }}

	return kv
}

`

var tempDelegate = `
// Save create a new model or update it 
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) Save() error {
	if {{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model == nil {
		return query.ErrModelNotSet
	}

	id, _, err := {{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model.SaveOrUpdate(*{{ lowercase $m.Name }}Self)
	if err != nil {
		return err 
	}

	{{ lowercase $m.Name }}Self.Id = id
	return nil
}

// Delete remove a {{ $m.Name }}
func ({{ lowercase $m.Name }}Self *{{ camel $m.Name }}) Delete() error {
	if {{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model == nil {
		return query.ErrModelNotSet
	}

	_, err := {{ lowercase $m.Name }}Self.{{ lowercase $m.Name }}Model.DeleteById({{ lowercase $m.Name }}Self.Id)
	if err != nil {
		return err 
	}

	return nil
}
`

func GetTemplate() string {
	return fmt.Sprintf(temp, tempEntity, tempRelation, tempDelegate, tempScope, tempWrap, tempModel)
}
