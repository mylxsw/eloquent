package generator

var temp = `
// !!! DO NOT EDIT THIS FILE
package {{ .PackageName }} 

import (
	{{ range $i, $imp := packages }}
	"{{ $imp }}"{{ end }}
)

func init() {
{{ range $i, $m := .Models }}{{ if $m.Definition.SoftDelete }}
	// Add{{camel $m.Name }}GlobalScope assign a global scope to a model for soft delete
	Add{{ camel $m.Name }}GlobalScope("soft_delete", func(builder query.Condition) {
		builder.WhereNull("deleted_at")
	})
{{ end }}{{ end }}
}

{{ range $i, $m := .Models }}
// {{ camel $m.Name }} is a {{ camel $m.Name }} object
type {{ camel $m.Name }} struct {
	original *{{ lowercase $m.Name }}Original

	Id int64{{ range $j, $f := $m.Definition.Fields }}
	{{ camel $f.Name }} {{ $f.Type }}{{ end }}
	{{ if not $m.Definition.WithoutCreateTime }}
	CreatedAt time.Time{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
	UpdatedAt time.Time{{ end }}{{ if $m.Definition.SoftDelete }}
	DeletedAt null.Time{{ end }}
}

// {{ lowercase $m.Name }}Original is an object which stores original {{ camel $m.Name }} from database
type {{ lowercase $m.Name }}Original struct {
	Id int64{{ range $j, $f := $m.Definition.Fields }}
	{{ camel $f.Name }} {{ $f.Type }}{{ end }}
	{{ if not $m.Definition.WithoutCreateTime }}
	CreatedAt time.Time{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
	UpdatedAt time.Time{{ end }}{{ if $m.Definition.SoftDelete }}
	DeletedAt null.Time{{ end }}
}

// Staled identify whether the object has been modified
func ({{ $m.Name }} *{{ camel $m.Name }}) Staled() bool {
	if {{ $m.Name }}.original == nil {
		{{ $m.Name }}.original = &{{ lowercase $m.Name }}Original {}
	}

	if {{ $m.Name }}.Id != {{ $m.Name }}.original.Id {
		return true
	}

	{{ range $j, $f := $m.Definition.Fields }}
	if {{ $m.Name }}.{{ camel $f.Name }} != {{ $m.Name }}.original.{{ camel $f.Name }} {
		return true
	}{{ end }}

	{{ if not $m.Definition.WithoutCreateTime }}
	if {{ $m.Name }}.CreatedAt != {{ $m.Name }}.original.CreatedAt {
		return true
	}{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
	if {{ $m.Name }}.UpdatedAt != {{ $m.Name }}.original.UpdatedAt {
		return true
	}{{ end }}{{ if $m.Definition.SoftDelete }}
	if {{ $m.Name }}.DeletedAt != {{ $m.Name }}.original.DeletedAt {
		return true
	}{{ end }}

	return false
}

// StaledKV return all fields has been modified
func ({{ $m.Name }} *{{ camel $m.Name }}) StaledKV() query.KV {
	kv := make(query.KV, 0)

	if {{ $m.Name }}.original == nil {
		{{ $m.Name }}.original = &{{ lowercase $m.Name }}Original {}
	}

	if {{ $m.Name }}.Id != {{ $m.Name }}.original.Id {
		kv["id"] = {{ $m.Name }}.Id
	}

	{{ range $j, $f := $m.Definition.Fields }}
	if {{ $m.Name }}.{{ camel $f.Name }} != {{ $m.Name }}.original.{{ camel $f.Name }} {
		kv["{{ snake $f.Name }}"] = {{ $m.Name }}.{{ camel $f.Name }}
	}{{ end }}

	{{ if not $m.Definition.WithoutCreateTime }}
	if {{ $m.Name }}.CreatedAt != {{ $m.Name }}.original.CreatedAt {
		kv["created_at"] = {{ $m.Name }}.CreatedAt
	}{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
	if {{ $m.Name }}.UpdatedAt != {{ $m.Name }}.original.UpdatedAt {
		kv["updated_at"] = {{ $m.Name }}.UpdatedAt
	}{{ end }}{{ if $m.Definition.SoftDelete }}
	if {{ $m.Name }}.DeletedAt != {{ $m.Name }}.original.DeletedAt {
		kv["deleted_at"] = {{ $m.Name }}.DeletedAt
	}{{ end }}

	return kv
}

// {{ camel $m.Name }}Delegate is an delegate which add some model powers to object
type {{ camel $m.Name }}Delegate struct {
	delegate *{{ camel $m.Name }}Model
	{{ lowercase $m.Name }} *{{ camel $m.Name }}
}

// Delegate create a {{ camel $m.Name }} for {{ $m.Name }}
func ({{ $m.Name }} *{{ camel $m.Name }}) Delegate(m *{{ camel $m.Name }}Model) *{{ camel $m.Name }}Delegate {
	return &{{ camel $m.Name }}Delegate {
		delegate: m,
		{{ lowercase $m.Name }}: {{ $m.Name }},
	}
}

// Save create a new model or update it 
func (d *{{ camel $m.Name }}Delegate) Save() error {
	id, _, err := d.delegate.SaveOrUpdate(*d.{{ lowercase $m.Name }})
	if err != nil {
		return err 
	}

	d.{{ lowercase $m.Name }}.Id = id
	return nil
}

// Delete remove a {{ $m.Name }}
func (d *{{ camel $m.Name }}Delegate) Delete() error {
	_, err := d.delegate.DeleteById(d.{{ lowercase $m.Name }}.Id)
	if err != nil {
		return err 
	}

	return nil
}

type {{ lower_camel $m.Name }}Wrap struct { 
	Id null.Int{{ range $j, $f := $m.Definition.Fields }}	
	{{ camel $f.Name }} {{ wrap_type $f.Type }}{{ end }}
	{{ if not $m.Definition.WithoutCreateTime }}
	CreatedAt null.Time{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
	UpdatedAt null.Time{{ end }}{{ if $m.Definition.SoftDelete }}
	DeletedAt null.Time{{ end }}
}

func (w {{ lower_camel $m.Name }}Wrap) To{{ camel $m.Name }} () {{ camel $m.Name }} {
	return {{ camel $m.Name }} {
		original: &{{ lowercase $m.Name }}Original {
			Id: w.Id.Int64,{{ range $j, $f := $m.Definition.Fields }}
			{{ camel $f.Name }}: {{ unwrap_type $f.Name $f.Type }},{{ end }}
			{{ if not $m.Definition.WithoutCreateTime }}
			CreatedAt: w.CreatedAt.Time,{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
			UpdatedAt: w.UpdatedAt.Time,{{ end }}{{ if $m.Definition.SoftDelete }}
			DeletedAt: w.DeletedAt,{{ end }}
		},
		Id: w.Id.Int64,{{ range $j, $f := $m.Definition.Fields }}
		{{ camel $f.Name }}: {{ unwrap_type $f.Name $f.Type }},{{ end }}
		{{ if not $m.Definition.WithoutCreateTime }}
		CreatedAt: w.CreatedAt.Time,{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}
		UpdatedAt: w.UpdatedAt.Time,{{ end }}{{ if $m.Definition.SoftDelete }}
		DeletedAt: w.DeletedAt,{{ end }}
	}
}

// {{ camel $m.Name }}Model is a model which encapsulates the operations of the object
type {{ camel $m.Name }}Model struct {
	db *sql.DB
	tableName string

	excludeGlobalScopes []string
	includeLocalScopes []string
}

type {{ lowercase $m.Name }}Scope struct {
	name  string
	apply func(builder query.Condition)
}

var {{ lowercase $m.Name }}GlobalScopes = make([]{{ lowercase $m.Name }}Scope, 0)
var {{ lowercase $m.Name }}LocalScopes = make([]{{ lowercase $m.Name }}Scope, 0)

var {{ lowercase $m.Name }}TableName = "{{ table $i }}"

func Set{{ camel $m.Name }}Table (tableName string) {
	{{ lowercase $m.Name }}TableName = tableName
}

// New{{ camel $m.Name }}Model create a {{ camel $m.Name }}Model
func New{{ camel $m.Name }}Model (db *sql.DB) *{{ camel $m.Name }}Model {
	return &{{ camel $m.Name }}Model {
		db: db, 
		tableName: {{ lowercase $m.Name }}TableName,
		excludeGlobalScopes: make([]string, 0),
		includeLocalScopes: make([]string, 0),
	}
}

// Add{{ camel $m.Name }}GlobalScope assign a global scope to a model
func Add{{ camel $m.Name }}GlobalScope(name string, apply func(builder query.Condition)) {
	{{ lowercase $m.Name }}GlobalScopes = append({{ lowercase $m.Name }}GlobalScopes, {{ lowercase $m.Name }}Scope{name: name, apply: apply})
}

// Add{{ camel $m.Name }}LocalScope assign a local scope to a model
func Add{{ camel $m.Name }}LocalScope(name string, apply func(builder query.Condition)) {
	{{ lowercase $m.Name }}LocalScopes = append({{ lowercase $m.Name }}LocalScopes, {{ lowercase $m.Name }}Scope{name: name, apply: apply})
}

func (m *{{ camel $m.Name }}Model) applyScope() query.Condition {
	scopeCond := query.ConditionBuilder()
	for _, g := range {{ lowercase $m.Name }}GlobalScopes {
		if m.globalScopeEnabled(g.name) {
			g.apply(scopeCond)
		}
	}

	for _, s := range {{ lowercase $m.Name }}LocalScopes {
		if m.localScopeEnabled(s.name) {
			s.apply(scopeCond)
		}
	}

	return scopeCond
}

func (m *{{ camel $m.Name }}Model) localScopeEnabled(name string) bool {
	for _, n := range m.includeLocalScopes {
		if name == n {
			return true
		}
	}

	return false
}

func (m *{{ camel $m.Name }}Model) globalScopeEnabled(name string) bool {
	for _, n := range m.excludeGlobalScopes {
		if name == n {
			return false
		}
	}
	
	return true
}

{{ if $m.Definition.SoftDelete }}
// WithTrashed force soft deleted models to appear in a result set
func (m *{{ camel $m.Name }}Model) WithTrashed() *{{ camel $m.Name }}Model {
	return m.WithoutGlobalScopes("soft_delete")
}
{{ end }}

func (m *{{ camel $m.Name }}Model) clone() *{{ camel $m.Name }}Model {
	return &{{ camel $m.Name }}Model{
		db: m.db, 
		tableName: m.tableName,
		excludeGlobalScopes: append([]string{}, m.excludeGlobalScopes...),
		includeLocalScopes: append([]string{}, m.includeLocalScopes...),
	}
}

// WithoutGlobalScopes remove a global scope for given query
func (m *{{ camel $m.Name }}Model) WithoutGlobalScopes(names ...string) *{{ camel $m.Name }}Model {
	mc := m.clone()
	mc.excludeGlobalScopes = append(mc.excludeGlobalScopes, names...)

	return mc
}

// WithLocalScopes add a local scope for given query
func (m *{{ camel $m.Name }}Model) WithLocalScopes(names ...string) *{{ camel $m.Name }}Model {
	mc := m.clone()
	mc.includeLocalScopes = append(mc.includeLocalScopes, names...)

	return mc
}

// Find retrieve a model by its primary key
func (m *{{ camel $m.Name }}Model) Find(id int64) ({{ camel $m.Name }}, error) {
	return m.First(query.Builder().Where("id", "=", id))
}

// Exists return whether the records exists for a given query
func (m *{{ camel $m.Name }}Model) Exists(builder query.SQLBuilder) (bool, error) {
	count, err := m.Count(builder)
	return count > 0, err
}

// Count return model count for a given query
func (m *{{ camel $m.Name }}Model) Count(builder query.SQLBuilder) (int64, error) {
	sqlStr, params := builder.Table(m.tableName).ResolveCount()
	
	rows, err := m.db.Query(sqlStr, params...)
	if err != nil {
		return 0, err
	}

	rows.Next()
	var res int64
	if err := rows.Scan(&res); err != nil {
		return 0, err
	}

	return res, nil
}

func (m *{{ camel $m.Name }}Model) Paginate(builder query.SQLBuilder, page int64, perPage int64) ([]{{ camel $m.Name }}, query.PaginateMeta, error) {
	if page <= 0 {
		page = 1
	}

	if perPage <= 0 {
		perPage = 15
	}

	meta := query.PaginateMeta {
		PerPage: perPage,
		Page: page,
	}

	count, err := m.Count(builder)
	if err != nil {
		return nil, meta, err
	}

	meta.Total = count
	meta.LastPage = count / perPage
	if count % perPage != 0 {
		meta.LastPage += 1
	}

	res, err := m.Get(builder.Limit(perPage).Offset((page - 1) * perPage))
	if err != nil {
		return res, meta, err
	}

	return res, meta, nil
}

// Get retrieve all results for given query
func (m *{{ camel $m.Name }}Model) Get(builder query.SQLBuilder) ([]{{ camel $m.Name }}, error) {
	builder = builder.Table(m.tableName).Select("id"{{ if not $m.Definition.WithoutCreateTime }}, "created_at"{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}, "updated_at"{{ end }}{{ range $j, $f := assignable_fields $m.Definition.Fields }}, "{{ snake $f.Name }}"{{ end }}{{ if $m.Definition.SoftDelete }}, "deleted_at"{{ end }})
	sqlStr, params := builder.AppendCondition(m.applyScope()).ResolveQuery()
	
	rows, err := m.db.Query(sqlStr, params...)
	if err != nil {
		return nil, err
	}

	{{ lowercase $m.Name }}s := make([]{{ camel $m.Name }}, 0)
	for rows.Next() {
		var {{ lowercase $m.Name }}Var {{ lower_camel $m.Name }}Wrap
		if err := rows.Scan(&{{ lowercase $m.Name }}Var.Id{{ if not $m.Definition.WithoutCreateTime }}, &{{ lowercase $m.Name }}Var.CreatedAt{{ end }}{{ if not $m.Definition.WithoutUpdateTime }}, &{{ lowercase $m.Name }}Var.UpdatedAt{{ end }}{{ range $j, $f := assignable_fields $m.Definition.Fields }}, &{{ lowercase $m.Name }}Var.{{ camel $f.Name }}{{ end }}{{ if $m.Definition.SoftDelete }}, &{{ lowercase $m.Name }}Var.DeletedAt{{ end }}); err != nil {
			return nil, err
		}

		{{ lowercase $m.Name }}s = append({{ lowercase $m.Name }}s, {{ lowercase $m.Name }}Var.To{{ camel $m.Name }}())
	}

	return {{ lowercase $m.Name }}s, nil
}

// First return first result for given query
func (m *{{ camel $m.Name }}Model) First(builder query.SQLBuilder) ({{ camel $m.Name }}, error) {
	res, err := m.Get(builder.Limit(1))
	if err != nil {
		return {{ camel $m.Name }}{}, err 
	}

	if len(res) == 0 {
		return {{ camel $m.Name }}{}, sql.ErrNoRows
	}

	return res[0], nil
}

// Create save a new {{ $m.Name }} to database
func (m *{{ camel $m.Name }}Model) Create(kv query.KV) (int64, error) {
	{{ if not $m.Definition.WithoutCreateTime }}kv["created_at"] = time.Now(){{ end }}
	{{ if not $m.Definition.WithoutUpdateTime }}kv["updated_at"] = time.Now(){{ end }}

	sqlStr, params := query.Builder().Table(m.tableName).ResolveInsert(kv)

	res, err := m.db.Exec(sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.LastInsertId()	
}

// SaveAll save all {{ $m.Name }}s to database
func (m *{{ camel $m.Name }}Model) SaveAll({{ lowercase $m.Name }}s []{{ camel $m.Name }}) ([]int64, error) {
	ids := make([]int64, 0)
	for _, {{ lowercase $m.Name }} := range {{ lowercase $m.Name }}s {
		id, err := m.Save({{ lowercase $m.Name }})
		if err != nil {
			return ids, err
		}

		ids = append(ids, id)
	}

	return ids, nil
}

// Save save a {{ $m.Name }} to database
func (m *{{ camel $m.Name }}Model) Save({{ lowercase $m.Name }} {{ camel $m.Name }}) (int64, error) {
	return m.Create(query.KV{ {{ range $j, $f := assignable_fields $m.Definition.Fields }}
		"{{ snake $f.Name }}": {{ lowercase $m.Name }}.{{ camel $f.Name }},{{ end }}
	})	
}

// SaveOrUpdate save a new {{ $m.Name }} or update it when it has a id > 0
func (m *{{ camel $m.Name }}Model) SaveOrUpdate({{ lowercase $m.Name }} {{ camel $m.Name }}) (id int64, updated bool, err error) {
	if {{ lowercase $m.Name }}.Id > 0 {
		_, _err := m.UpdateById({{ lowercase $m.Name }}.Id, {{ lowercase $m.Name }})
		return {{ lowercase $m.Name }}.Id, true, _err
	}

	_id, _err := m.Save({{ lowercase $m.Name }})
	return _id, false, _err
}

// UpdateFields update kv for a given query
func (m *{{ camel $m.Name }}Model) UpdateFields(builder query.SQLBuilder, kv query.KV) (int64, error) {
	if len(kv) == 0 {
		return 0, nil
	}

	{{ if not $m.Definition.WithoutUpdateTime }}
	kv["updated_at"] = time.Now()
	{{ end }} 
	
	builder = builder.AppendCondition(m.applyScope())
	sqlStr, params := builder.Table(m.tableName).ResolveUpdate(kv)

	res, err := m.db.Exec(sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// Update update a model for given query
func (m *{{ camel $m.Name }}Model) Update(builder query.SQLBuilder, {{ lowercase $m.Name }} {{ camel $m.Name }}) (int64, error) {
	return m.UpdateFields(builder, {{ lowercase $m.Name }}.StaledKV())
}

// UpdateById update a model by id
func (m *{{ camel $m.Name }}Model) UpdateById(id int64, {{ lowercase $m.Name }} {{ camel $m.Name }}) (int64, error) {
	return m.Update(query.Builder().Where("id", "=", id), {{ lowercase $m.Name }})
}

{{ if $m.Definition.SoftDelete }}
// ForceDelete permanently remove a soft deleted model from the database
func (m *{{ camel $m.Name }}Model) ForceDelete(builder query.SQLBuilder) (int64, error) {
	m2 := m.WithTrashed()

	sqlStr, params := builder.AppendCondition(m2.applyScope()).Table(m2.tableName).ResolveDelete()

	res, err := m2.db.Exec(sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

// ForceDeleteById permanently remove a soft deleted model from the database by id
func (m *{{ camel $m.Name }}Model) ForceDeleteById(id int64) (int64, error) {
	return m.ForceDelete(query.Builder().Where("id", "=", id))
}

// Restore restore a soft deleted model into an active state
func (m *{{ camel $m.Name }}Model) Restore(builder query.SQLBuilder) (int64, error) {
	m2 := m.WithTrashed()
	return m2.UpdateFields(builder, query.KV {
		"deleted_at": nil,
	})
}

// RestoreById restore a soft deleted model into an active state by id
func (m *{{ camel $m.Name }}Model) RestoreById(id int64) (int64, error) {
	return m.Restore(query.Builder().Where("id", "=", id))
}
{{ end }}

// Delete remove a model
func (m *{{ camel $m.Name }}Model) Delete(builder query.SQLBuilder) (int64, error) {
	{{ if $m.Definition.SoftDelete }}
	return m.UpdateFields(builder, query.KV {
		"deleted_at": time.Now(),
	})
	{{ else }}
	sqlStr, params := builder.AppendCondition(m.applyScope()).Table(m.tableName).ResolveDelete()

	res, err := m.db.Exec(sqlStr, params...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
	{{ end }}
}

// DeleteById remove a model by id
func (m *{{ camel $m.Name }}Model) DeleteById(id int64) (int64, error) {
	return m.Delete(query.Builder().Where("id", "=", id))
}

{{ end }}

`

func GetTemplate() string {
	return temp
}
